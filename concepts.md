# Theoretical concepts

This documentation page aims to shortly summarize some of the most important theory related to the certification preparation and overall knowledge about containers and container security ðŸ“š

- [Theoretical concepts](#theoretical-concepts)
  - [Docker](#docker)
    - [Docker architecture](#docker-architecture)
      - [Docker Engine](#docker-engine)
      - [Docker Objects](#docker-objects)
    - [Container Low Level](#container-low-level)
      - [Namespaces](#namespaces)
        - [PID Namespace (Process Isolation)](#pid-namespace-process-isolation)
        - [Network Namespace (Network Isolation)](#network-namespace-network-isolation)
        - [Mount Namespace (Filesystem Isolation)](#mount-namespace-filesystem-isolation)
        - [User Namespace (User ID Isolation)](#user-namespace-user-id-isolation)
        - [UTS Namespace (Hostname Isolation)](#uts-namespace-hostname-isolation)
        - [IPC Namespace (Inter-Process Communication Isolation)](#ipc-namespace-inter-process-communication-isolation)
        - [Cgroup Namespace (Resource Limitation View)](#cgroup-namespace-resource-limitation-view)
      - [cgroups (Control Groups)](#cgroups-control-groups)
      - [Capabilities](#capabilities)
      - [Modifying Capabilities](#modifying-capabilities)
      - [Security Considerations](#security-considerations)
    - [Docker alternatives](#docker-alternatives)
    - [Docker Networking](#docker-networking)
    - [Docker Volume Management](#docker-volume-management)
      - [Understanding Docker Volumes:](#understanding-docker-volumes)
      - [Key Points to Remember:](#key-points-to-remember)
    - [Docker Layers - Dockerfile, Image, and Containers](#docker-layers---dockerfile-image-and-containers)
    - [Dockerfile Instructions](#dockerfile-instructions)
    - [Docker Compose Instructions](#docker-compose-instructions)
      - [Examples](#examples)
    - [Docker Registry](#docker-registry)
      - [Image Reference Formats:](#image-reference-formats)
      - [Hosted vs Cloud-Based Repositories](#hosted-vs-cloud-based-repositories)
  - [Docker Security](#docker-security)
    - [Image Security](#image-security)
    - [Container Security](#container-security)
    - [Docker Daemon/Host Security](#docker-daemonhost-security)
    - [Docker Registry Security](#docker-registry-security)
    - [Additional Measures](#additional-measures)

## Docker

### Docker architecture

![Docker architecture](docs/img/ccse-docker-architecture.png)

Docker is a powerful platform designed to make it easier to create, deploy, and run applications by using containers. Containers allow developers to package an application with all of its dependencies into a standardized unit for software development. Docker's architecture is key to its functionality, enabling both development and operations teams to work more efficiently. Here's an overview of Docker's architecture within a 70-line constraint:

#### Docker Engine

The Docker Engine is the core of Docker, a lightweight and powerful open-source containerization technology combined with a workable API. The Engine creates and manages Docker containers. It's a client-server based application comprising three major components:

1. `` Docker Daemon (`dockerd`): `` The server part of the engine that listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. It's the process that actually executes the containers.

2. `REST API:` An interface that programs can use to talk to the daemon and instruct it what to do.

3. `` Docker CLI (`docker`): `` The command line interface that allows users to interact with Docker using commands.

#### Docker Objects

- `Images:` An immutable file that's essentially a snapshot of a container. Images serve as the basis of containers. An image includes everything needed to run an application - the code or binary, runtimes, dependencies, and any other filesystem objects required.

- `Containers:` An abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same hardware more efficiently than if using virtual machines. Containers are created from images, and they can be started, stopped, moved, and deleted.

- `Volumes:` Provide persistent storage for a Docker container. They are essential for when you need to store data generated by and used by Docker containers.

- `Networks:` Enable isolated networks to be defined and managed by Docker. They provide connectivity between containers on the same host or across different hosts.

---

### Container Low Level

Docker containers use various Linux kernel features to isolate and manage resources. These include namespaces, cgroups, and capabilities, which are essential for container security and functionality.

#### Namespaces

Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. Docker utilizes namespaces to provide the isolated workspace called the container. When you run a container, Docker creates a set of namespaces for that container, each serving a specific aspect of isolation. Here's an extension on all the key namespaces created by Docker for each container:

##### PID Namespace (Process Isolation)

- **Purpose:** Isolates the process ID number space, meaning processes in a container can have the same PID as the host system but are treated independently. This ensures process isolation and management within containers.
  
  ```bash
  docker run --pid=host ...
  ```

##### Network Namespace (Network Isolation)

- **Purpose:** Provides each container with its own network stack, including IP addresses, routing tables, and sockets. Containers can have their own private networks, isolated from the host system.

  ```bash
  docker run --network=bridge ...
  ```

##### Mount Namespace (Filesystem Isolation)

- **Purpose:** Isolates filesystem mount points. Changes to the filesystem in a container do not affect the host filesystem or other containers.

  ```bash
  docker run -v /host/path:/container/path ...
  ```

##### User Namespace (User ID Isolation)

- **Purpose:** Maps user IDs inside the container to different user IDs on the host system. This prevents a root user inside the container from having root privileges on the host system, enhancing security.

  ```bash
  docker run --userns-remap=default ...
  ```

##### UTS Namespace (Hostname Isolation)

- **Purpose:** Allows each container to have its own hostname and domain name, separate from the host and other containers. This is useful for virtual hosting and isolation.

  ```bash
  docker run --hostname=mycontainer ...
  ```

##### IPC Namespace (Inter-Process Communication Isolation)

- **Purpose:** Isolates IPC (Inter-Process Communication) resources between containers. This prevents processes in different containers from seeing or interacting with IPC resources in other containers or the host.

  ```bash
  docker run --ipc=private ...
  ```

##### Cgroup Namespace (Resource Limitation View)

- **Purpose:** Virtualizes the view of cgroup resources. Processes within the container can see a cgroup hierarchy that is distinct from the host, allowing for finer-grained control over resource allocation and measurement.

#### cgroups (Control Groups)

cgroups limit, account for, and isolate the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes. Docker uses cgroups to prevent containers from consuming too many resources and affecting other containers on the host.

- ``Memory Limit:`` Restricts a container's memory usage.
  
  ```bash
  docker run -m 512m ...
  ```

- ``CPU Limit:`` Restricts a container's CPU usage.
  
  ```bash
  docker run --cpus=1.5 ...
  ```

#### Capabilities

Linux capabilities partition the privileges of the superuser into distinct, smaller privilege sets that can be independently enabled or disabled for Docker containers. This granularity ensures containers operate with the least privilege required, enhancing security.

Here's an overview of some key Linux capabilities and their purposes:

| Capability | Purpose |
|------------|---------|
| `CAP_CHOWN` | Allows changing the owner of files and directories. |
| `CAP_DAC_OVERRIDE` | Bypasses file read, write, and execute permission checks. |
| `CAP_DAC_READ_SEARCH` | Bypasses file read permission checks and directory read and execute permission checks. |
| `CAP_FOWNER` | Bypasses permission checks on operations that require the filesystem UID of the process to match the UID of the file. |
| `CAP_FSETID` | Allows setting file UID and GID to arbitrary values. |
| `CAP_KILL` | Allows sending signals to processes owned by other users. |
| `CAP_NET_BIND_SERVICE` | Allows binding to TCP/UDP sockets below 1024. |
| `CAP_NET_RAW` | Allows using RAW and PACKET sockets, enabling ping and other network diagnostics. |
| `CAP_SETGID` | Allows changing the GID of processes. |
| `CAP_SETUID` | Allows changing the UID of processes. |
| `CAP_SETPCAP` | Allows transferring or removing any capability in the calling process's permitted capability set to or from any other process. |
| `CAP_SYS_ADMIN` | Provides a broad set of administrative operations like mounting filesystems, configuring network interfaces, and more. |
| `CAP_SYS_CHROOT` | Allows changing the root directory of the calling process. |
| `CAP_SYS_PTRACE` | Allows tracing arbitrary processes using ptrace. |
| `CAP_SYS_TIME` | Allows setting the system clock. |

For more information check [Docker security official documentation page](https://docs.docker.com/engine/security/).

#### Modifying Capabilities

- **Dropping Capabilities:** You can remove specific or all default capabilities from a container to minimize its privileges further.

  ```bash
  docker run --cap-drop ALL --cap-add NET_BIND_SERVICE ...
  ```

- **Adding Capabilities:** Conversely, you can grant additional capabilities to a container if required for its operation.

  ```bash
  docker run --cap-add SYS_TIME ...
  ```

#### Security Considerations

- ``Namespace Isolation:`` While namespaces provide isolation, they are not foolproof. Processes with sufficient privileges can still interact with other namespaces, potentially leading to security breaches.
  
- ``cgroups Limitations:`` cgroups help with resource isolation but do not control all types of resource consumption. For example, they don't directly limit the total file system cache.

- ``Capabilities Precautions:`` Granting unnecessary capabilities can increase the attack surface of the container. Always adhere to the principle of least privilege, granting only the capabilities required for the container to function.

By combining namespaces, cgroups, and capabilities, Docker provides a powerful and flexible system for managing containerized applications while maintaining a strong security posture. However, understanding these mechanisms and their implications is crucial for securing container environments.

______________________________________________________________________

### Docker alternatives

1. [Podman](https://podman.io/) - Podman is a daemonless, open source, Linux native tool designed to make it easy to find, run, build, share and deploy applications using Open Containers Initiative (OCI) Containers and Container Images.
2. [CRI-O:](https://cri-o.io/) - Container management solution optimized for Kubernetes compliant with OCI specification.
3. [Linux Containers - LXC](https://linuxcontainers.org/lxc/getting-started/)

______________________________________________________________________

### Docker Networking

Docker supports multiple networking options, each tailored for specific use cases:

- `Bridge:` The default network driver, suitable for containers' communication on the same host.
- `Host:` Removes network isolation between container and host, offering performance improvement.
- `Overlay:` Enables network communication between containers across different hosts, crucial for Docker Swarm.
- `Macvlan:` Allows assigning a MAC address to a container, making it appear as a physical device on the network.
- `None:` Disables all networking, useful for containers that don't require network communication.

> \[!NOTE\]
> Docker default network is `Bridge`.

---

### Docker Volume Management

Docker volumes are essential for persisting data generated by and used within Docker containers. Managed entirely by Docker, volumes offer several advantages, including ease of backup, restoration, and migration. They are stored on the Docker host, ensuring data persists beyond the container's lifecycle.

#### Understanding Docker Volumes:

1. ``Bind Mounts (Host Volumes):``
   Bind mounts link a directory on the host's filesystem to a container, allowing direct access and modification of files from both the host and the container. It's specified using an absolute path on the host.

   Example:
   ```bash
   docker run -v /path/on/host:/path/in/container some-image
   ```

2. ``Anonymous Volumes:``
   Anonymous volumes are not named and are created to hold data temporarily until the container is deleted. They are ideal for non-persistent, ephemeral data.

   Example:
   ```bash
   docker run -v /path/in/container some-image
   ```

3. ``Named Volumes (Volume Mounts):``
   Named volumes, or volume mounts, offer a more durable and portable way to store container data compared to bind mounts. They are easy to backup, restore, and can be used by multiple containers.

   Example:
   ```bash
   docker volume create my-named-volume
   docker run -v my-named-volume:/path/in/container some-image
   ```

4. ``tmpfs Mounts (Temporary Volumes):``
   `tmpfs` mounts allow you to create temporary volumes that are stored in the host's memory only. This is particularly useful when you want to store sensitive information that you don't want to persist on disk.

   Example:
   ```bash
   docker run --tmpfs /path/in/container some-image
   ```

![Docker volume illustration](./docs/img/ccse-docker-volumes.png)

#### Key Points to Remember:

- ``Volume Location:`` Volumes exist on the Docker host. When using Docker in a client-server model, remember that paths specified for volumes refer to the host where the Docker daemon runs, not necessarily the local client machine.

- ``Persistent Storage:`` Docker volumes are designed to persist data, separate from the container's lifecycle. Even when a container is removed, the volume remains until explicitly deleted.

- ``Data Isolation:`` Using volumes can help to isolate your data, allowing containers to remain lightweight and stateless, which is a best practice for containerized applications.

Leveraging these various types of volumes effectively ensures data persistence, security, and efficiency in managing the state of Dockerized applications. Always plan your data management strategy according to the needs of your application and the environment in which your containers run.

> [!IMPORTANT]
> ``Misconceptions:`` For beginners, it can be misleading when the Docker CLI and Daemon are on the same host, as it appears as if you're directly mapping a local host folder to a container folder. However, **the binding is actually taking place on the host where the Docker daemon runs**.

---

### Docker Layers - Dockerfile, Image, and Containers

Docker uses a layered filesystem to build images and run containers efficiently. Here's the relationship between Dockerfile, images, and containers, as illustrated in the diagram:

- ``Dockerfile``: A text document containing all the commands to build a Docker image. It starts from a base image and executes instructions that create layers.
- ``Docker Image``: A read-only template composed of layered filesystems used to execute code in a Docker container. Each instruction in the Dockerfile creates a new layer in the image.
- ``Docker Container``: A runnable instance of an image with an additional writable layer on top of the image's layers. Containers share the base image layers, making them lightweight and fast.

``Union Layers and Reusability``: Docker images are built using union filesystems that combine multiple layers into a single view. Layers are reused across different images to save space, and changes within a running container are stored in the writable layer, keeping the underlying image unchanged for reuse.

![Docker concepts relationship](docs/img/dockerfile-image-container-layers.png)
______________________________________________________________________

### Dockerfile Instructions

- `FROM`: Initializes a new build stage and sets the base image.
- `RUN`: Executes commands in a new layer on top of the current image and commits the results.
- `CMD`: Provides defaults for an executing container.
- `LABEL`: Adds metadata to an image.
- `EXPOSE`: Informs Docker that the container listens on specific network ports at runtime.
- `ENV`: Sets the environment variable.
- `ADD`: Copies new files, directories, or remote file URLs and adds them to the filesystem of the image.
- `COPY`: Copies new files or directories and adds them to the filesystem of the container.
- `ENTRYPOINT`: Configures a container that will run as an executable.
- `VOLUME`: Creates a mount point with the specified name and marks it as holding externally mounted volumes from the native host or other containers.
- `USER`: Sets the username or UID to use when running the image.
- `WORKDIR`: Sets the working directory for any RUN, CMD, ENTRYPOINT, COPY, and ADD instructions that follow it.
- `ARG`: Defines a variable that users can pass at build-time to the builder with the docker build command.
- `ONBUILD`: Adds a trigger instruction to be executed at a later time, when the image is used as the base for another build.
- `STOPSIGNAL`: Sets the system call signal that will be sent to the container to exit.
- `HEALTHCHECK`: Tells Docker how to test a container to check that it is still working.
- `SHELL`: Allows the default shell used for the shell form of commands to be overridden.

> \[!IMPORTANT\]
> Do not forget this security tips to define more secure images to proper Dockerfile quality.

01. `Use Official Images`: Stick to official or verified images to reduce the risk of vulnerabilities.
02. `Minimize Base Images`: Use minimal base images like Alpine to reduce attack surface.
03. `Avoid Running as Root`: Use `USER` to switch to a non-root user for running applications.
04. `Use Multi-Stage Builds`: Separate the build environment from the runtime environment to minimize the final image size and reduce risk.
05. `Specify Exact Versions`: In the `FROM` instruction, specify exact versions of images to avoid unexpected changes.
06. `Keep Secrets Out`: Never hard-code secrets in your Dockerfile. Use secrets management tools or Docker secrets.
07. `Use COPY Over ADD`: Prefer `COPY` for copying local files, use `ADD` for URLs and tar extraction.
08. `Regularly Scan Images for Vulnerabilities`: Integrate security scans into your CI/CD pipeline to catch vulnerabilities early.
09. `Limit Build Context`: Use `.dockerignore` files to exclude unnecessary files from the build context to prevent accidental inclusion of sensitive files.
10. `Keep Containers Up-to-Date`: Regularly update and rebuild containers to include security patches.

______________________________________________________________________

### Docker Compose Instructions

Docker Compose is a tool for defining and running multi-container Docker applications. Below are the majority of instructions available in a `docker-compose.yml` file, along with examples and security tips.

```yaml
version: '3.8'  # Specify the Docker Compose version

services:  # Define the services your application consists of
  web:  # Name of the first service
    image: nginx:alpine  # Specify the image to use
    ports:
      - "80:80"  # Map port 80 of the container to port 80 on the host
    depends_on:
      - app  # This service depends on the `app` service

  app:  # Name of the second service
    build: ./app  # Path to the directory containing Dockerfile
    environment:
      - DEBUG=0  # Environment variable to control debug mode

volumes:  # Define volumes for persistent data
  db-data:  # Name of the volume

networks:  # Define networks for inter-service communication
  frontend:  # Name of the network
```

#### Examples

- **Defining a Service with a Build Context and Environment Variables:**

```yaml
services:
  example-service:
    build:
      context: ./dir  # Directory containing the Dockerfile
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
    environment:
      VARIABLE_NAME: value  # Set environment variables
```

- **Using Volumes for Persistent Data:**

```yaml
services:
  db:
    image: postgres:latest
    volumes:
      - db-data:/var/lib/postgresql/data  # Mount the `db-data` volume

volumes:
  db-data:  # Declare the volume
```

- **Setting Up Custom Networks:**

```yaml
services:
  web:
    networks:
      - frontend  # Connect to the `frontend` network

networks:
  frontend:  # Define the network
```

> \[!IMPORTANT\]
> Do not forget to check this security tips for Docker Compose.

1. `Use Fixed Version Tags`: Always use fixed version tags for images to ensure consistency and prevent unexpected changes. Using hash is a very recommended practice for security.

```yaml
image: nginx:1.19.0-alpine
```

2. `Restrict Ports`: Only expose necessary ports to limit access to your services.

```yaml
ports:
  - "127.0.0.1:80:80"  # Only bind to localhost
```

3. `Use Environment Files`: Instead of hardcoding environment variables, especially secrets, use an environment file.

```yaml
env_file:
  - web.env
```

4. `Enable Logging Options`: Configure logging options to manage and rotate logs properly, preventing disk space issues.

```yaml
logging:
  driver: json-file
  options:
    max-size: "200k"
    max-file: "10"
```

5. `Secure Networks`: Create custom networks and use them to isolate containers.

```yaml
networks:
  default:
    driver: bridge
```

6. `Run as Non-Root User`: Ensure services run as a non-root user if the Dockerfile supports it.

```yaml
user: "1001"
```

7. `Use Read-Only Volumes`: When possible, mount volumes as read-only.

```yaml
volumes:
  - type: volume
    source: my-volume
    target: /app/data
    read_only: true
```

8. `Implement Health Checks`: Define health checks to ensure services are running as expected.

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost"]
  interval: 30s
  timeout: 10s
  retries: 5
```

> \[!NOTE\]
> For full details and options, take a look at [Docker compose specification](https://github.com/compose-spec/compose-spec)

______________________________________________________________________

### Docker Registry

The Docker registry stores Docker images, which can be referenced in various formats depending on the registry and organizational requirements.

#### Image Reference Formats:

![Image formats](./docs/img/ccse-docker-registry.png)

1. **Namespaced Registry Format (Used in Openshift, Harbor):**
   Images are stored in a format that includes the registry address, project namespace, repository name, and optionally, the tag and digest.

   ```
   registry-url/project-name/repository-name:tag@sha256:digest
   ```

   Example:
   ```bash
   myregistry.com/myproject/nginx:1.17@sha256:25a0d4
   ```

2. **Standard Registry Format (Used in Registry V2, Docker Hub):**
   This format includes the registry address, repository name, and optionally, the tag and digest, but omits the namespace.

   ```
   registry-url/repository-name:tag@sha256:digest
   ```

   Example:
   ```bash
   docker.io/nginx:1.17@sha256:25a0d4
   ```

> [!IMPORTANT]
> These formats are used to pull specific image versions, ensuring immutability and traceability by referencing the exact image content hash. The hash is not required but really recommended as a security measure.


In namespaces registries, separating projects or teams into namespaces can help organize and manage access controls. In standard registries, images are typically organized by repository names and tags without an additional project or namespace layer.


#### Hosted vs Cloud-Based Repositories

Hosted and cloud-based Docker repositories provide storage solutions for Docker images with varying features and security options. Here's a comparison from both functional and security perspectives:

| Feature / Security | Hosted Repository | Cloud-Based Repository |
|-------------------|------------------|-----------------------|
| ``Deployment`` | On-premises infrastructure, manual setup and maintenance. | Provided as a service, managed by a third-party provider. |
| ``Accessibility`` | Typically within an internal network or VPN. | Accessible over the internet with proper credentials. |
| ``Scalability`` | Limited by on-premises hardware. | Highly scalable, on-demand resources. |
| ``Redundancy`` | Dependent on local infrastructure setup. | Multiple regions and zones for high availability. |
| ``Compliance`` | Must be manually enforced and audited. | Often provides compliance certifications out-of-the-box. |
| ``Security Updates`` | Manually applied, requires internal processes. | Managed by the service provider, automatically applied. |
| ``Access Control`` | Managed internally, can integrate with existing systems. | Provided by the platform, with options for integration. |
| ``Image Scanning`` | Can be configured with third-party tools. | Often included as a service feature. |
| ``Backup and Recovery`` | Managed by internal IT policies. | Handled by the provider, with varying backup options. |

Hosted repositories offer more control but require more management overhead, while cloud-based repositories provide ease of use and managed services at the cost of less direct control. The choice between the two depends on organizational requirements, resources, and preferences.

---

## Docker Security

Ensuring the security of Docker containers involves a multi-faceted approach, covering image security, container runtime security, Docker daemon/host security measures, and Docker registry security. The Center for Internet Security (CIS) Docker Benchmark provides a comprehensive set of practices designed to safeguard your Docker environment. Below is a summary tailored for a Docker security markdown section, highlighting key measures based on the CIS benchmark:

> [!CAUTION]
> This is not an exhaustive list of all possible controls but serves as a solid starting point for securing your Docker environment. Delve deeper into each area for a more secure and robust configuration.

### Image Security

- ``Use Trusted Base Images:`` Only use official or trusted base images for your containers. Regularly scan these images for vulnerabilities and ensure they are up to date.
- ``Minimize Image Layers:`` Reduce the number of layers in your images to minimize complexity and potential attack surface.
- ``Avoid Storing Secrets:`` Do not store secrets in Docker images. Use Docker secrets or other secure mechanisms for managing sensitive information.
- ``Static Analysis:`` Regularly perform static analysis of your container images to detect vulnerabilities or misconfigurations.

### Container Security

- ``Use Non-Root Users:`` Run containers as a non-root user whenever possible to limit the potential impact of exploits.
- ``Limit Container Resources:`` Use Docker's resource constraints (CPU, memory, etc.) to prevent denial-of-service (DoS) attacks.
- ``Network Segmentation:`` Apply network segmentation principles to container networking. Use custom bridge networks and avoid using the host network mode.
- ``Read-Only Filesystems:`` Where possible, run containers with read-only filesystems using the `--read-only` flag to prevent tampering.
- ``Logging and Monitoring:`` Implement logging and monitoring to detect suspicious activities or security incidents within containers.

### Docker Daemon/Host Security

- ``Secure the Docker Daemon:`` Ensure the Docker daemon is configured securely, using TLS for authentication and encrypting network traffic.
- ``Regular Updates:`` Keep the Docker engine and host operating system up to date with the latest security patches.
- ``Host Hardening:`` Apply general host hardening guidelines to the Docker host to minimize vulnerabilities and reduce the attack surface.
- ``Control Docker Daemon Access:`` Restrict access to the Docker daemon and use role-based access control (RBAC) where applicable.
- ``Audit Docker Host and Daemon:`` Regularly audit the Docker host and daemon configurations and logs for any security issues or misconfigurations.

### Docker Registry Security

- ``Use TLS:`` Ensure communication with your Docker registry is encrypted using TLS.
- ``Authentication:`` Implement robust authentication mechanisms to control who can push and pull images.
- ``Access Control:`` Use role-based access controls to limit user capabilities based on their role.
- ``Registry Scanning:`` Integrate vulnerability scanning to detect security issues before images are deployed.
- ``Audit Logs:`` Enable and monitor audit logs to keep track of activities performed on the registry.

### Additional Measures

- ``Security Scanning:`` Utilize tools for continuous security scanning of images and containers to detect vulnerabilities early.
- ``Implement Docker Bench for Security:`` Use the Docker Bench for Security script to automatically check for dozens of common best-practices around deploying Docker containers in production.

By implementing these security measures, you will significantly enhance the security posture of your Docker environment, ensuring that containerized applications are protected against various threats.
