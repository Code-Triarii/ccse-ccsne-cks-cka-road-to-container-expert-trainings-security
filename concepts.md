# Theoretical concepts

This documentation page aims to shortly summarize some of the most important theory related to the certification preparation and overall knowledge about containers and container security ðŸ“š

- [Theoretical concepts](#theoretical-concepts)
  - [Docker](#docker)
    - [Docker architecture](#docker-architecture)
      - [Docker Engine](#docker-engine)
      - [Docker Objects](#docker-objects)
    - [Docker alternatives](#docker-alternatives)
    - [Docker Networking](#docker-networking)
    - [Docker Volume Management](#docker-volume-management)
      - [Understanding Docker Volumes:](#understanding-docker-volumes)
      - [Key Points to Remember:](#key-points-to-remember)
    - [Docker Layers - Dockerfile, Image, and Containers](#docker-layers---dockerfile-image-and-containers)
    - [Dockerfile Instructions](#dockerfile-instructions)
    - [Docker Compose Instructions](#docker-compose-instructions)
      - [Examples](#examples)
  - [Docker Security](#docker-security)
    - [Image Security](#image-security)
    - [Container Security](#container-security)
    - [Docker Daemon/Host Security](#docker-daemonhost-security)
    - [Docker Registry Security](#docker-registry-security)
    - [Additional Measures](#additional-measures)

## Docker

### Docker architecture

![Docker architecture](docs/img/ccse-docker-architecture.png)

Docker is a powerful platform designed to make it easier to create, deploy, and run applications by using containers. Containers allow developers to package an application with all of its dependencies into a standardized unit for software development. Docker's architecture is key to its functionality, enabling both development and operations teams to work more efficiently. Here's an overview of Docker's architecture within a 70-line constraint:

#### Docker Engine

The Docker Engine is the core of Docker, a lightweight and powerful open-source containerization technology combined with a workable API. The Engine creates and manages Docker containers. It's a client-server based application comprising three major components:

1. `` Docker Daemon (`dockerd`): `` The server part of the engine that listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. It's the process that actually executes the containers.

2. `REST API:` An interface that programs can use to talk to the daemon and instruct it what to do.

3. `` Docker CLI (`docker`): `` The command line interface that allows users to interact with Docker using commands.

#### Docker Objects

- `Images:` An immutable file that's essentially a snapshot of a container. Images serve as the basis of containers. An image includes everything needed to run an application - the code or binary, runtimes, dependencies, and any other filesystem objects required.

- `Containers:` An abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same hardware more efficiently than if using virtual machines. Containers are created from images, and they can be started, stopped, moved, and deleted.

- `Volumes:` Provide persistent storage for a Docker container. They are essential for when you need to store data generated by and used by Docker containers.

- `Networks:` Enable isolated networks to be defined and managed by Docker. They provide connectivity between containers on the same host or across different hosts.

______________________________________________________________________

### Docker alternatives

1. [Podman](https://podman.io/) - Podman is a daemonless, open source, Linux native tool designed to make it easy to find, run, build, share and deploy applications using Open Containers Initiative (OCI) Containers and Container Images.
2. [CRI-O:](https://cri-o.io/) - Container management solution optimized for Kubernetes compliant with OCI specification.
3. [Linux Containers - LXC](https://linuxcontainers.org/lxc/getting-started/)

______________________________________________________________________

### Docker Networking

Docker supports multiple networking options, each tailored for specific use cases:

- `Bridge:` The default network driver, suitable for containers' communication on the same host.
- `Host:` Removes network isolation between container and host, offering performance improvement.
- `Overlay:` Enables network communication between containers across different hosts, crucial for Docker Swarm.
- `Macvlan:` Allows assigning a MAC address to a container, making it appear as a physical device on the network.
- `None:` Disables all networking, useful for containers that don't require network communication.

> \[!NOTE\]
> Docker default network is `Bridge`.

---

### Docker Volume Management

Docker volumes are essential for persisting data generated by and used within Docker containers. Managed entirely by Docker, volumes offer several advantages, including ease of backup, restoration, and migration. They are stored on the Docker host, ensuring data persists beyond the container's lifecycle.

#### Understanding Docker Volumes:

1. ``Bind Mounts (Host Volumes):``
   Bind mounts link a directory on the host's filesystem to a container, allowing direct access and modification of files from both the host and the container. It's specified using an absolute path on the host.

   Example:
   ```bash
   docker run -v /path/on/host:/path/in/container some-image
   ```

2. ``Anonymous Volumes:``
   Anonymous volumes are not named and are created to hold data temporarily until the container is deleted. They are ideal for non-persistent, ephemeral data.

   Example:
   ```bash
   docker run -v /path/in/container some-image
   ```

3. ``Named Volumes (Volume Mounts):``
   Named volumes, or volume mounts, offer a more durable and portable way to store container data compared to bind mounts. They are easy to backup, restore, and can be used by multiple containers.

   Example:
   ```bash
   docker volume create my-named-volume
   docker run -v my-named-volume:/path/in/container some-image
   ```

4. ``tmpfs Mounts (Temporary Volumes):``
   `tmpfs` mounts allow you to create temporary volumes that are stored in the host's memory only. This is particularly useful when you want to store sensitive information that you don't want to persist on disk.

   Example:
   ```bash
   docker run --tmpfs /path/in/container some-image
   ```

![Docker volume illustration](./docs/img/ccse-docker-volumes.png)

#### Key Points to Remember:

- **Volume Location:** Volumes exist on the Docker host. When using Docker in a client-server model, remember that paths specified for volumes refer to the host where the Docker daemon runs, not necessarily the local client machine.

- **Persistent Storage:** Docker volumes are designed to persist data, separate from the container's lifecycle. Even when a container is removed, the volume remains until explicitly deleted.

- **Data Isolation:** Using volumes can help to isolate your data, allowing containers to remain lightweight and stateless, which is a best practice for containerized applications.

Leveraging these various types of volumes effectively ensures data persistence, security, and efficiency in managing the state of Dockerized applications. Always plan your data management strategy according to the needs of your application and the environment in which your containers run.

> [!IMPORTANT]
> ``Misconceptions:`` For beginners, it can be misleading when the Docker CLI and Daemon are on the same host, as it appears as if you're directly mapping a local host folder to a container folder. However, **the binding is actually taking place on the host where the Docker daemon runs**.

---

### Docker Layers - Dockerfile, Image, and Containers

Docker uses a layered filesystem to build images and run containers efficiently. Here's the relationship between Dockerfile, images, and containers, as illustrated in the diagram:

- ``Dockerfile``: A text document containing all the commands to build a Docker image. It starts from a base image and executes instructions that create layers.
- ``Docker Image``: A read-only template composed of layered filesystems used to execute code in a Docker container. Each instruction in the Dockerfile creates a new layer in the image.
- ``Docker Container``: A runnable instance of an image with an additional writable layer on top of the image's layers. Containers share the base image layers, making them lightweight and fast.

``Union Layers and Reusability``: Docker images are built using union filesystems that combine multiple layers into a single view. Layers are reused across different images to save space, and changes within a running container are stored in the writable layer, keeping the underlying image unchanged for reuse.

![Docker concepts relationship](docs/img/dockerfile-image-container-layers.png)
______________________________________________________________________

### Dockerfile Instructions

- `FROM`: Initializes a new build stage and sets the base image.
- `RUN`: Executes commands in a new layer on top of the current image and commits the results.
- `CMD`: Provides defaults for an executing container.
- `LABEL`: Adds metadata to an image.
- `EXPOSE`: Informs Docker that the container listens on specific network ports at runtime.
- `ENV`: Sets the environment variable.
- `ADD`: Copies new files, directories, or remote file URLs and adds them to the filesystem of the image.
- `COPY`: Copies new files or directories and adds them to the filesystem of the container.
- `ENTRYPOINT`: Configures a container that will run as an executable.
- `VOLUME`: Creates a mount point with the specified name and marks it as holding externally mounted volumes from the native host or other containers.
- `USER`: Sets the username or UID to use when running the image.
- `WORKDIR`: Sets the working directory for any RUN, CMD, ENTRYPOINT, COPY, and ADD instructions that follow it.
- `ARG`: Defines a variable that users can pass at build-time to the builder with the docker build command.
- `ONBUILD`: Adds a trigger instruction to be executed at a later time, when the image is used as the base for another build.
- `STOPSIGNAL`: Sets the system call signal that will be sent to the container to exit.
- `HEALTHCHECK`: Tells Docker how to test a container to check that it is still working.
- `SHELL`: Allows the default shell used for the shell form of commands to be overridden.

> \[!IMPORTANT\]
> Do not forget this security tips to define more secure images to proper Dockerfile quality.

01. `Use Official Images`: Stick to official or verified images to reduce the risk of vulnerabilities.
02. `Minimize Base Images`: Use minimal base images like Alpine to reduce attack surface.
03. `Avoid Running as Root`: Use `USER` to switch to a non-root user for running applications.
04. `Use Multi-Stage Builds`: Separate the build environment from the runtime environment to minimize the final image size and reduce risk.
05. `Specify Exact Versions`: In the `FROM` instruction, specify exact versions of images to avoid unexpected changes.
06. `Keep Secrets Out`: Never hard-code secrets in your Dockerfile. Use secrets management tools or Docker secrets.
07. `Use COPY Over ADD`: Prefer `COPY` for copying local files, use `ADD` for URLs and tar extraction.
08. `Regularly Scan Images for Vulnerabilities`: Integrate security scans into your CI/CD pipeline to catch vulnerabilities early.
09. `Limit Build Context`: Use `.dockerignore` files to exclude unnecessary files from the build context to prevent accidental inclusion of sensitive files.
10. `Keep Containers Up-to-Date`: Regularly update and rebuild containers to include security patches.

______________________________________________________________________

### Docker Compose Instructions

Docker Compose is a tool for defining and running multi-container Docker applications. Below are the majority of instructions available in a `docker-compose.yml` file, along with examples and security tips.

```yaml
version: '3.8'  # Specify the Docker Compose version

services:  # Define the services your application consists of
  web:  # Name of the first service
    image: nginx:alpine  # Specify the image to use
    ports:
      - "80:80"  # Map port 80 of the container to port 80 on the host
    depends_on:
      - app  # This service depends on the `app` service

  app:  # Name of the second service
    build: ./app  # Path to the directory containing Dockerfile
    environment:
      - DEBUG=0  # Environment variable to control debug mode

volumes:  # Define volumes for persistent data
  db-data:  # Name of the volume

networks:  # Define networks for inter-service communication
  frontend:  # Name of the network
```

#### Examples

- **Defining a Service with a Build Context and Environment Variables:**

```yaml
services:
  example-service:
    build:
      context: ./dir  # Directory containing the Dockerfile
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
    environment:
      VARIABLE_NAME: value  # Set environment variables
```

- **Using Volumes for Persistent Data:**

```yaml
services:
  db:
    image: postgres:latest
    volumes:
      - db-data:/var/lib/postgresql/data  # Mount the `db-data` volume

volumes:
  db-data:  # Declare the volume
```

- **Setting Up Custom Networks:**

```yaml
services:
  web:
    networks:
      - frontend  # Connect to the `frontend` network

networks:
  frontend:  # Define the network
```

> \[!IMPORTANT\]
> Do not forget to check this security tips for Docker Compose.

1. `Use Fixed Version Tags`: Always use fixed version tags for images to ensure consistency and prevent unexpected changes. Using hash is a very recommended practice for security.

```yaml
image: nginx:1.19.0-alpine
```

2. `Restrict Ports`: Only expose necessary ports to limit access to your services.

```yaml
ports:
  - "127.0.0.1:80:80"  # Only bind to localhost
```

3. `Use Environment Files`: Instead of hardcoding environment variables, especially secrets, use an environment file.

```yaml
env_file:
  - web.env
```

4. `Enable Logging Options`: Configure logging options to manage and rotate logs properly, preventing disk space issues.

```yaml
logging:
  driver: json-file
  options:
    max-size: "200k"
    max-file: "10"
```

5. `Secure Networks`: Create custom networks and use them to isolate containers.

```yaml
networks:
  default:
    driver: bridge
```

6. `Run as Non-Root User`: Ensure services run as a non-root user if the Dockerfile supports it.

```yaml
user: "1001"
```

7. `Use Read-Only Volumes`: When possible, mount volumes as read-only.

```yaml
volumes:
  - type: volume
    source: my-volume
    target: /app/data
    read_only: true
```

8. `Implement Health Checks`: Define health checks to ensure services are running as expected.

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost"]
  interval: 30s
  timeout: 10s
  retries: 5
```

> \[!NOTE\]
> For full details and options, take a look at [Docker compose specification](https://github.com/compose-spec/compose-spec)

______________________________________________________________________

## Docker Security

Ensuring the security of Docker containers involves a multi-faceted approach, covering image security, container runtime security, Docker daemon/host security measures, and Docker registry security. The Center for Internet Security (CIS) Docker Benchmark provides a comprehensive set of practices designed to safeguard your Docker environment. Below is a summary tailored for a Docker security markdown section, highlighting key measures based on the CIS benchmark:

> [!CAUTION]
> This is not an exhaustive list of all possible controls but serves as a solid starting point for securing your Docker environment. Delve deeper into each area for a more secure and robust configuration.

### Image Security

- ``Use Trusted Base Images:`` Only use official or trusted base images for your containers. Regularly scan these images for vulnerabilities and ensure they are up to date.
- ``Minimize Image Layers:`` Reduce the number of layers in your images to minimize complexity and potential attack surface.
- ``Avoid Storing Secrets:`` Do not store secrets in Docker images. Use Docker secrets or other secure mechanisms for managing sensitive information.
- ``Static Analysis:`` Regularly perform static analysis of your container images to detect vulnerabilities or misconfigurations.

### Container Security

- ``Use Non-Root Users:`` Run containers as a non-root user whenever possible to limit the potential impact of exploits.
- ``Limit Container Resources:`` Use Docker's resource constraints (CPU, memory, etc.) to prevent denial-of-service (DoS) attacks.
- ``Network Segmentation:`` Apply network segmentation principles to container networking. Use custom bridge networks and avoid using the host network mode.
- ``Read-Only Filesystems:`` Where possible, run containers with read-only filesystems using the `--read-only` flag to prevent tampering.
- ``Logging and Monitoring:`` Implement logging and monitoring to detect suspicious activities or security incidents within containers.

### Docker Daemon/Host Security

- ``Secure the Docker Daemon:`` Ensure the Docker daemon is configured securely, using TLS for authentication and encrypting network traffic.
- ``Regular Updates:`` Keep the Docker engine and host operating system up to date with the latest security patches.
- ``Host Hardening:`` Apply general host hardening guidelines to the Docker host to minimize vulnerabilities and reduce the attack surface.
- ``Control Docker Daemon Access:`` Restrict access to the Docker daemon and use role-based access control (RBAC) where applicable.
- ``Audit Docker Host and Daemon:`` Regularly audit the Docker host and daemon configurations and logs for any security issues or misconfigurations.

### Docker Registry Security

- ``Use TLS:`` Ensure communication with your Docker registry is encrypted using TLS.
- ``Authentication:`` Implement robust authentication mechanisms to control who can push and pull images.
- ``Access Control:`` Use role-based access controls to limit user capabilities based on their role.
- ``Registry Scanning:`` Integrate vulnerability scanning to detect security issues before images are deployed.
- ``Audit Logs:`` Enable and monitor audit logs to keep track of activities performed on the registry.

### Additional Measures

- ``Security Scanning:`` Utilize tools for continuous security scanning of images and containers to detect vulnerabilities early.
- ``Implement Docker Bench for Security:`` Use the Docker Bench for Security script to automatically check for dozens of common best-practices around deploying Docker containers in production.

By implementing these security measures, you will significantly enhance the security posture of your Docker environment, ensuring that containerized applications are protected against various threats.
